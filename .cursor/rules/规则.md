# Cursor AIå¹¿å‘Šä»£æŠ•ç³»ç»Ÿå¼€å‘è§„åˆ™ v2.1

> **é¡¹ç›®åç§°**: AIå¹¿å‘Šä»£æŠ•ç³»ç»Ÿ
> **è§„åˆ™ç‰ˆæœ¬**: v2.1
> **æ›´æ–°æ—¥æœŸ**: 2025-11-11
> **æ–‡æ¡£ç±»å‹**: AIå¼€å‘çº¦æŸå’Œè§„èŒƒæŒ‡å—

æœ¬æ–‡ä»¶åŸºäºAIå¹¿å‘Šä»£æŠ•ç³»ç»Ÿv2.1æ¶æ„å’ŒæŠ€æœ¯è§„èŒƒï¼Œä¸ºCursor AIæä¾›è¯¦ç»†çš„å¼€å‘çº¦æŸï¼Œç¡®ä¿ä»£ç è´¨é‡ã€æ¶æ„ä¸€è‡´æ€§å’Œä¸šåŠ¡é€»è¾‘æ­£ç¡®æ€§ã€‚

---

## ğŸ¯ è§„åˆ™ç›®æ ‡

- **æ¶æ„ä¸€è‡´æ€§**: ç¡®ä¿æ‰€æœ‰ä»£ç éµå¾ªv2.1æŠ€æœ¯æ¶æ„å’Œè®¾è®¡åŸåˆ™
- **ä»£ç è´¨é‡**: ç»Ÿä¸€ä»£ç è§„èŒƒï¼Œå‡å°‘æŠ€æœ¯å€ºåŠ¡
- **ä¸šåŠ¡æ­£ç¡®æ€§**: éµå¾ªçŠ¶æ€æœºè§„åˆ™ï¼Œé˜²æ­¢ä¸šåŠ¡é€»è¾‘é”™è¯¯
- **å®‰å…¨åˆè§„**: å®æ–½æƒé™æ§åˆ¶å’Œæ•°æ®å®‰å…¨ç­–ç•¥
- **å¼€å‘æ•ˆç‡**: é¿å…é‡å¤æ€§é”™è¯¯ï¼Œæé«˜å¼€å‘æ•ˆç‡

---

## ğŸ“‹ ä¸€ã€æŠ€æœ¯æ ˆçº¦æŸ

### 1.1 æŠ€æœ¯æ ˆå®šä¹‰
```yaml
# åç«¯æŠ€æœ¯æ ˆï¼ˆä¸¥æ ¼ç¦æ­¢æ›´æ”¹ï¼‰
backend:
  framework: FastAPI 0.104+
  python: 3.11+
  orm: SQLAlchemy 2.0+ (åŒæ­¥ç‰ˆæœ¬)
  validation: Pydantic v2
  database: PostgreSQL (Supabaseæ‰˜ç®¡)
  cache: Redis 7+
  queue: RQ (Redis Queue)

# å‰ç«¯æŠ€æœ¯æ ˆï¼ˆä¸¥æ ¼ç¦æ­¢æ›´æ”¹ï¼‰
frontend:
  framework: Next.js 14+
  language: TypeScript 5.0+
  ui: Tailwind CSS + shadcn/ui
  state: SWR / React Query
  auth: Supabase Auth + JWT

# éƒ¨ç½²æŠ€æœ¯æ ˆ
deployment:
  containerization: Docker + Docker Compose
  proxy: Nginx
  ci_cd: GitHub Actions
  monitoring: Prometheus + Grafana + Sentry
```

### 1.2 é¡¹ç›®ç»“æ„çº¦æŸ
```
ai-ad-spend/
â”œâ”€â”€ backend/                    # åç«¯æœåŠ¡
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ main.py          # FastAPIåº”ç”¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ core/            # æ ¸å¿ƒå·¥å…·å’Œé…ç½®
â”‚   â”‚   â”œâ”€â”€ models/          # SQLAlchemyæ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ schemas/         # Pydanticæ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ routers/         # APIè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ services/        # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â””â”€â”€ middleware/      # ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ tests/               # åç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ alembic/            # æ•°æ®åº“è¿ç§»
â”‚   â”œâ”€â”€ requirements.txt     # Pythonä¾èµ–
â”‚   â””â”€â”€ .env.example        # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”œâ”€â”€ frontend/                  # å‰ç«¯åº”ç”¨
â”‚   â”œâ”€â”€ app/               # Next.js App Routeré¡µé¢
â”‚   â”œâ”€â”€ components/        # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ lib/               # å·¥å…·å’Œé…ç½®
â”‚   â”œâ”€â”€ hooks/             # è‡ªå®šä¹‰Hooks
â”‚   â”œâ”€â”€ styles/            # æ ·å¼æ–‡ä»¶
â”‚   â”œâ”€â”€ package.json       # ä¾èµ–å’Œè„šæœ¬
â”‚   â””â”€â”€ .env.local         # ç¯å¢ƒå˜é‡
â”œâ”€â”€ docs/                     # é¡¹ç›®æ–‡æ¡£
â”œâ”€â”€ scripts/                  # éƒ¨ç½²å’Œå·¥å…·è„šæœ¬
â”œâ”€â”€ docker-compose.*.yml     # Dockeré…ç½®
â””â”€â”€ .gitignore               # Gitå¿½ç•¥æ–‡ä»¶
```

---

## ğŸ”’ äºŒã€ä»£ç ç”Ÿæˆæ ¸å¿ƒè§„åˆ™

### 2.1 ç»Ÿä¸€å“åº”ç»“æ„å¼ºåˆ¶è¦æ±‚

æ‰€æœ‰APIæ¥å£**å¿…é¡»**ä½¿ç”¨v2.1ä¸»æ–‡æ¡£ç¬¬5ç« å®šä¹‰çš„ç»Ÿä¸€å“åº”æ ¼å¼ï¼š

```python
# backend/core/response.py - æ ‡å‡†å“åº”å‡½æ•°ï¼ˆå¿…é¡»ä½¿ç”¨ï¼‰
from fastapi.responses import JSONResponse
from datetime import datetime
from typing import Any, Optional, Dict, Union

def success_response(
    data: Any = None,
    message: str = "æ“ä½œæˆåŠŸ",
    code: str = "SUCCESS",
    meta: Optional[Dict[str, Any]] = None,
    request_id: Optional[str] = None
) -> JSONResponse:
    """æˆåŠŸå“åº”"""
    response_data = {
        "success": True,
        "data": data,
        "message": message,
        "code": code,
        "request_id": request_id or generate_request_id(),
        "timestamp": datetime.utcnow().isoformat(),
        "meta": meta or {}
    }
    return JSONResponse(response_data)

def error_response(
    message: str,
    code: str = "UNKNOWN_ERROR",
    status_code: int = 400,
    details: Optional[Dict[str, Any]] = None,
    request_id: Optional[str] = None
) -> JSONResponse:
    """é”™è¯¯å“åº”"""
    response_data = {
        "success": False,
        "error": {
            "code": code,
            "message": message,
            "details": details
        },
        "request_id": request_id or generate_request_id(),
        "timestamp": datetime.utcnow().isoformat()
    }
    return JSONResponse(response_data, status_code=status_code)

# ç¦æ­¢ç›´æ¥ä½¿ç”¨
# âŒ ç¦æ­¢ï¼š
# âŒ return {"data": {...}}
# âŒ raise HTTPException(detail={...})
# âŒ è‡ªå®šä¹‰è¿”å›æ ¼å¼

# âœ… å¿…é¡»ä½¿ç”¨ï¼š
# âœ… return success_response(data=data)
# âœ… return error_response("æ“ä½œå¤±è´¥", "VALIDATION_ERROR")
```

### 2.2 RESTful APIè·¯å¾„è§„èŒƒ

```python
# è·¯å¾„å‘½åè§„èŒƒ
@api_router.get("/api/projects")
@api_router.post("/api/projects/{project_id}")
@api_router.put("/api/projects/{project_id}")
@api_router.delete("/api/projects/{project_id}")

# åµŒå¥—èµ„æºè·¯å¾„
@api_router.get("/api/projects/{project_id}/accounts")
@api_router.post("/api/projects/{project_id}/accounts/{account_id}/reports")

# ä¸šåŠ¡è·¯å¾„è§„èŒƒ
@api_router.post("/api/auth/login")
@api_router.post("/api/auth/logout")
@api_router.post("/api/recharge/request")
@api_router.post("/api/reconciliation/run")
```

### 2.3 æ•°æ®æ¨¡å‹å¼ºåˆ¶çº¦æŸ

```python
# models/base.py - åŸºç¡€æ¨¡å‹ç±»
from sqlalchemy import Column, DateTime, UUID
from sqlalchemy.sql import func

class BaseModel:
    """æ‰€æœ‰æ¨¡å‹çš„åŸºç¡€ç±»"""
    id = Column(UUID(as_uuid=True, primary_key=True, default=uuid.uuid4)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

# å­—æ®µç±»å‹å¼ºåˆ¶è¦æ±‚
# âœ… é‡‘é¢å­—æ®µï¼šDecimal(12, 2) - ç¦æ­¢ä½¿ç”¨float
# âœ… å¸ƒå°”å­—æ®µï¼šBoolean - ç¦æ­¢ä½¿ç”¨int(0,1)
# âœ… æ—¶é—´å­—æ®µï¼šDateTime - ç¦æ­¢ä½¿ç”¨å­—ç¬¦ä¸²
# âœ… å¤–é”®ï¼šUUID - å¿…é¡»å»ºç«‹æ­£ç¡®å…³ç³»

# models/ad_account.py - ç¤ºä¾‹
from sqlalchemy import Column, Decimal, String, Text
from sqlalchemy.orm import relationship

class AdAccount(BaseModel):
    name = Column(String(200), nullable=False)
    account_id = Column(String(100), nullable=False, unique=True)
    platform = Column(String(20), nullable=False, default='facebook')
    status = Column(String(20), nullable=False, default='new')
    daily_budget = Column(Decimal(10, 2), default=0.00)
    total_spend = Column(Decimal(15, 2), default=0.00)

    # å¤–é”®å…³ç³»
    project_id = Column(UUID(as_uuid=True, nullable=False, foreign_key="projects.id")
    assigned_user_id = Column(UUID(as_uuid=True, nullable=True, foreign_key="users.id")

    # å…³ç³»å®šä¹‰
    project = relationship("Project", back_populates="accounts")
    assigned_user = relationship("User", back_populates="accounts")
```

### 2.4 Pydantic Schemaå¼ºåˆ¶çº¦æŸ

```python
# schemas/ad_account.py - æ•°æ®ä¼ è¾“æ¨¡å‹
from pydantic import BaseModel, Config, Field, validator
from decimal import Decimal
from typing import Optional

# åŸºç¡€é…ç½®
class Config:
    # é‡‘é¢åºåˆ—åŒ–
    json_encoders = {
        Decimal: lambda v: float(v)  # è¿”å›å‰ç«¯ä½¿ç”¨
    }
    from_attributes = True  # æ”¯æŒä»æ¨¡å‹å®ä¾‹åˆ›å»º

# åˆ›å»ºæ¨¡å‹
class AdAccountCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=200)
    platform: str = Field(default="facebook")
    daily_budget: Decimal = Field(ge=0, decimal_places=2)
    project_id: str
    assigned_user_id: Optional[str] = None

# æ›´æ–°æ¨¡å‹
class AdAccountUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=200)
    status: Optional[str] = None
    daily_budget: Optional[Decimal] = Field(None, ge=0, decimal_places=2)

# å“åº”æ¨¡å‹
class AdAccountResponse(BaseModel):
    id: str
    name: str
    platform: str
    status: str
    daily_budget: Decimal
    total_spend: Decimal
    created_at: datetime
    updated_at: datetime
    project_id: str
    assigned_user_id: Optional[str]

    class Config:
        from_attributes = True
        json_encoders = {
            Decimal: lambda v: float(v)
        }

# åˆ—è¡¨æ¨¡å‹
class AdAccountList(BaseModel):
    items: list[AdAccountResponse]
    total: int
    page: int
    size: int
    pages: int

# ç¦æ­¢ä½¿ç”¨
# âŒ ç¦æ­¢ï¼šfloatå­—æ®µ
# âŒ ç¦æ­¢ï¼šç¡¬ç¼–ç é»˜è®¤å€¼
# âŒ ç¦æ­¢ï¼šå¿½ç•¥å¿…è¦å­—æ®µéªŒè¯

# âœ… å¿…é¡»ä½¿ç”¨
# âœ… Decimalç±»å‹ç”¨äºé‡‘é¢
# âœ… FieldéªŒè¯çº¦æŸ
# âœ… Config.json_encodersè®¾ç½®
# âœ… from_attributes = True
```

---

## ğŸ”„ ä¸‰ã€çŠ¶æ€æœºå¼ºåˆ¶çº¦æŸ

### 3.1 å……å€¼ç”³è¯·çŠ¶æ€æœºï¼ˆä¸¥æ ¼éµå¾ªv2.1ä¸»æ–‡æ¡£ç¬¬2ç« ï¼‰

```python
# models/recharge_request.py
from enum import Enum

class RechargeStatus(str, Enum):
    DRAFT = "draft"         # æŠ•æ‰‹æäº¤
    PENDING = "pending"       # æˆ·ç®¡å®¡æ ¸
    APPROVED = "approved"     # è´¢åŠ¡æ‰¹å‡†
    PAID = "paid"            # å·²æ”¯ä»˜
    POSTED = "posted"        # å·²å…¥è´¦
    REJECTED = "rejected"     # è¢«é©³å›

class RechargeRequest(BaseModel):
    status: RechargeStatus = RechargeStatus.DRAFT

    def can_approve(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å®¡æ ¸"""
        return self.status == RechargeStatus.PENDING

    def can_reject(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥é©³å›"""
        return self.status in [RechargeStatus.PENDING, RechargeStatus.APPROVED]

    def can_pay(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¯ä»˜"""
        return self.status == RechargeStatus.APPROVED

    def can_post(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯ä»¥å…¥è´¦"""
        return self.status == RechargeStatus.PAID

# çŠ¶æ€è½¬æ¢éªŒè¯å‡½æ•°
def validate_recharge_status_transition(
    current_status: RechargeStatus,
    target_status: RechargeStatus,
    user_role: str,
    user_id: str
) -> bool:
    """éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•"""

    # çŠ¶æ€è½¬æ¢è§„åˆ™çŸ©é˜µ
    valid_transitions = {
        RechargeStatus.DRAFT: {
            RechargeStatus.PENDING: ['data_clerk'],  # æŠ•æ‰‹â†’æäº¤
        },
        RechargeStatus.PENDING: {
            RechargeStatus.APPROVED: ['data_clerk'],  # æˆ·ç®¡â†’æ‰¹å‡†
            RechargeStatus.REJECTED: ['data_clerk']   # æˆ·ç®¡â†’é©³å›
        },
        RechargeStatus.APPROVED: {
            RechargeStatus.PAID: ['finance']        # è´¢åŠ¡â†’æ”¯ä»˜
        },
        RechargeStatus.PAID: {
            RechargeStatus.POSTED: ['system']      # ç³»ç»Ÿâ†’å…¥è´¦
        },
        RechargeStatus.REJECTED: {
            RechargeStatus.DRAFT: ['data_clerk']   # é©ºç®¡å‘˜â†’é‡æ–°æäº¤
        }
    }

    allowed_roles = valid_transitions.get(current_status, {})

    if target_status not in allowed_roles:
        return False

    return user_role in allowed_roles[target_status]

# åœ¨è·¯ç”±ä¸­ä½¿ç”¨çŠ¶æ€éªŒè¯
@router.post("/api/recharge/{request_id}/approve")
async def approve_recharge(
    request_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    recharge = db.query(RechargeRequest).filter(RechargeRequest.id == request_id).first()
    if not recharge:
        return error_response("å……å€¼ç”³è¯·ä¸å­˜åœ¨", "NOT_FOUND", 404)

    if not validate_recharge_status_transition(
        recharge.status,
        RechargeStatus.APPROVED,
        current_user.role,
        current_user.id
    ):
        return error_response("çŠ¶æ€è½¬æ¢ä¸è¢«å…è®¸", "INVALID_STATE_TRANSITION", 422)

    # æ‰§è¡ŒçŠ¶æ€è½¬æ¢
    recharge.status = RechargeStatus.APPROVED
    recharge.data_clerk_id = current_user.id
    recharge.data_clerk_approved_at = datetime.utcnow()

    db.commit()

    return success_response(data=recharge, message="å……å€¼ç”³è¯·å·²æ‰¹å‡†")
```

### 3.2 å¹¿å‘Šè´¦æˆ·çŠ¶æ€æœºå¼ºåˆ¶çº¦æŸ

```python
# models/ad_account.py
class AccountStatus(str, Enum):
    NEW = "new"           # æ–°å»º
    TESTING = "testing"     # æµ‹è¯•æœŸ
    ACTIVE = "active"       # æ­£å¸¸æŠ•æ”¾
    SUSPENDED = "suspended" # æš‚åœ
    DEAD = "dead"           # è´¦ç¦
    ARCHIVED = "archived"   # å½’æ¡£

# çŠ¶æ€è½¬æ¢éªŒè¯
def validate_account_status_transition(
    current_status: AccountStatus,
    target_status: AccountStatus,
    context: Dict[str, Any]
) -> bool:
    """éªŒè¯è´¦æˆ·çŠ¶æ€è½¬æ¢"""

    # è‡ªåŠ¨è½¬æ¢è§„åˆ™
    auto_transitions = {
        AccountStatus.NEW: {
            AccountStatus.TESTING: {"min_days": 7, "require_spend": True},
        },
        AccountStatus.ACTIVE: {
            AccountStatus.SUSPENDED: {"no_spend_days": 3},
            AccountStatus.DEAD: {"api_error": True}
        }
    }

    # æ‰‹åŠ¨è½¬æ¢è§„åˆ™
    manual_transitions = {
        AccountStatus.SUSPENDED: {
            AccountStatus.ACTIVE: {"role": ["admin", "data_clerk"]},
            AccountStatus.ARCHIVED: {"role": ["admin"]}
        },
        AccountStatus.DEAD: {
            AccountStatus.ARCHIVED: {"role": ["admin"]}
        }
    }

    # æ£€æŸ¥è‡ªåŠ¨è½¬æ¢
    if current_status in auto_transitions:
        rules = auto_transitions[current_status].get(target_status, {})
        if all(context.get(rule_key, False) for rule_key, rule_value in rules.items()):
            return True

    # æ£€æŸ¥æ‰‹åŠ¨è½¬æ¢
    if current_status in manual_transitions:
        roles = manual_transitions[current_status].get(target_status, {})
        return context.get("user_role") in roles.get(target_role, [])

    return False
```

### 3.3 æ•°æ®å®Œæ•´æ€§å¼ºåˆ¶éªŒè¯

```python
# services/validation.py
from typing import Dict, Any
from sqlalchemy.orm import Session

def validate_cross_entity_consistency(
    payload: Dict[str, Any],
    db: Session,
    current_user: User,
    entity_type: str
) -> bool:
    """è·¨å®ä½“ä¸€è‡´æ€§éªŒè¯"""

    try:
        # éªŒè¯é¡¹ç›®-è´¦æˆ·-ç”¨æˆ·æƒé™é“¾
        if entity_type in ["daily_report", "recharge_request"]:
            account_id = payload.get("ad_account_id")
            project_id = payload.get("project_id")

            account = db.query(AdAccount).filter(AdAccount.id == account_id).first()
            if not account:
                raise ValueError(f"å¹¿å‘Šè´¦æˆ·ä¸å­˜åœ¨: {account_id}")

            if account.project_id != project_id:
                raise ValueError(f"è´¦æˆ·-é¡¹ç›®ä¸åŒ¹é…: {account.project_id} != {project_id}")

            if account.assigned_user_id != current_user.id:
                if current_user.role not in ["admin", "data_clerk"]:
                    raise ValueError(f"æ— æƒé™æ“ä½œè¯¥è´¦æˆ·")

        # éªŒè¯å››å±‚æ•°æ®å…³ç³»
        if entity_type == "recharge_request":
            project_id = payload.get("project_id")
            ad_account_id = payload.get("ad_account_id")

            # éªŒè¯è´¦æˆ·å±äºé¡¹ç›®
            account = db.query(AdAccount).filter(
                AdAccount.id == ad_account_id,
                AdAccount.project_id == project_id
            ).first()
            if not account:
                raise ValueError(f"è´¦æˆ·ä¸å±äºè¯¥é¡¹ç›®: {ad_account_id} @ {project_id}")

        # éªŒè¯å¤–é”®çº¦æŸ
        foreign_key_mappings = {
            "daily_report": ["ad_account_id", "user_id", "report_date"],
            "recharge_request": ["project_id", "ad_account_id", "user_id"],
            "ad_spend": ["ad_account_id", "user_id", "spend_date"]
        }

        required_keys = foreign_key_mappings.get(entity_type, [])
        for key in required_keys:
            if key not in payload or not payload[key]:
                raise ValueError(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {key}")

        return True

    except Exception as e:
        # è®°å½•éªŒè¯é”™è¯¯
        log_validation_error(
            entity_type=entity_type,
            error=str(e),
            user_id=current_user.id,
            payload=payload
        )
        return False
```

---

## ğŸ” å››ã€å®‰å…¨ä¸æƒé™å¼ºåˆ¶çº¦æŸ

### 4.1 è®¤è¯å’Œæƒé™æ§åˆ¶

```python
# backend/core/security.py
from fastapi import Depends, HTTPException, status
from jose import JWTError, jwt
import redis

# RLSä¸Šä¸‹æ–‡ä¸­é—´ä»¶ï¼ˆå¿…é¡»ä½¿ç”¨ï¼‰
class RLSContextMiddleware:
    async def dispatch(self, request, call_next):
        user = getattr(request.state, 'current_user', None)
        if user:
            db = request.state.db
            try:
                # è®¾ç½®RLSä¸Šä¸‹æ–‡
                db.execute(f"SELECT set_config('app.current_user_id', '{user.id}', true)")
                db.execute(f"SELECT set_config('app.current_role', '{user.role}', true)")
                db.commit()
            except Exception as e:
                # è®°å½•é”™è¯¯ä½†ä¸é˜»æ–­è¯·æ±‚
                log_error("RLSè®¾ç½®å¤±è´¥", str(e))

        response = await call_next(request)
        return response

# æƒé™ä¾èµ–ï¼ˆå¿…é¡»ä½¿ç”¨ï¼‰
async def get_current_user(
    request: Request,
    db: Session = Depends(get_db)
) -> User:
    """è·å–å½“å‰è®¤è¯ç”¨æˆ·"""

    # æ£€æŸ¥Authorizationå¤´
    authorization = request.headers.get("authorization")
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ç¼ºå°‘è®¤è¯ä»¤ç‰Œ",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # æå–å’ŒéªŒè¯JWT
    try:
        scheme, token = authorization.split(" ")
        if scheme.lower() != "bearer":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="æ— æ•ˆçš„è®¤è¯æ–¹æ¡ˆ"
            )

        payload = jwt.decode(
            token,
            os.getenv("JWT_SECRET"),
            algorithms=[os.getenv("JWT_ALGORITHM", "HS256")]
        )

        # æŸ¥æ‰¾ç”¨æˆ·
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="æ— æ•ˆçš„ä»¤ç‰Œè½½è·"
            )

        user = db.query(User).filter(User.id == user_id).first()
        if not user or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨"
            )

        return user

    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ä»¤ç‰ŒéªŒè¯å¤±è´¥"
        )

# è§’ç”±æƒé™éªŒè¯ï¼ˆå¿…é¡»ä½¿ç”¨ï¼‰
def require_permission(permission: str):
    """æƒé™éªŒè¯è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # è¿™é‡Œå‡è®¾current_userå·²é€šè¿‡get_current_useræ³¨å…¥
            current_user = kwargs.get("current_user")
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="éœ€è¦è®¤è¯"
                )

            # æ£€æŸ¥æƒé™
            if not has_permission(current_user, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"æƒé™ä¸è¶³: {permission}"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

def has_permission(user: User, permission: str) -> bool:
    """æ£€æŸ¥ç”¨æˆ·æƒé™"""
    if user.role == "admin":
        return True

    # æ ¹æ®è§’è‰²æ£€æŸ¥å…·ä½“æƒé™
    role_permissions = {
        "media_buyer": [
            "create_daily_report",
            "read_own_project",
            "create_recharge_request"
        ],
        "data_clerk": [
            "manage_accounts",
            "approve_reports",
            "approve_recharge_requests"
        ],
        "finance": [
            "approve_payments",
            "reconcile_financial",
            "view_financial_reports"
        ]
    ]

    return permission in role_permissions.get(user.role, [])
```

### 4.2 æ•°æ®å®‰å…¨å¼ºåˆ¶è¦æ±‚

```python
# å‰ç«¯ï¼šç¦æ­¢ç›´æ¥æ•°æ®åº“æ“ä½œ
# âœ… å…è®¸ï¼šåªè¯»æŸ¥è¯¢
# âŒ ç¦æ­¢ï¼šå†™å…¥ã€æ›´æ–°ã€åˆ é™¤

// æ­£ç¡®ç”¨æ³•
const { data, error } = await supabase
  .from('projects')
  .select('*')
  .eq('manager_id', userId)

// é”™è¯¯ç”¨æ³•
// âŒ ç¦æ­¢ç›´æ¥å†™å…¥æ•°æ®åº“
const { data, error } = await supabase
  .from('projects')
  .insert([{ name: 'New Project' }])

// âŒ ç¦æ­¢ç»•è¿‡API
fetch('/projects', {
  method: 'POST',
  body: JSON.stringify({ name: 'New Project' })
})
```

### 4.3 æ•æ„Ÿæ•°æ®å¤„ç†

```python
# ç¯å¢ƒå˜é‡å®‰å…¨ç®¡ç†
import os
from cryptography.fernet import Fernet

# å¿…é¡»åŠ å¯†çš„æ•æ„Ÿé…ç½®
class SecureConfig:
    JWT_SECRET: str = os.getenv("JWT_SECRET")
    SUPABASE_SERVICE_KEY: str = os.getenv("SUPABASE_SERVICE_KEY")
    DATABASE_URL: str = os.getenv("DATABASE_URL")

    @classmethod
    def validate(cls):
        """éªŒè¯æ‰€æœ‰å¿…éœ€çš„ç¯å¢ƒå˜é‡"""
        required_vars = [
            "JWT_SECRET",
            "SUPABASE_SERVICE_KEY",
            "DATABASE_URL"
        ]

        for var in required_vars:
            value = os.getenv(var)
            if not value:
                raise ValueError(f"ç¯å¢ƒå˜é‡ {var} æœªè®¾ç½®")

            # éªŒè¯æœ€å°é•¿åº¦
            if var in ["JWT_SECRET"] and len(value) < 32:
                raise ValueError(f"{var} é•¿åº¦ä¸è¶³ï¼ˆè‡³å°‘32å­—ç¬¦ï¼‰")

# æ•°æ®åŠ å¯†å¤„ç†
class DataEncryption:
    def __init__(self):
        self.key = os.getenv("ENCRYPTION_KEY").encode()
        self.cipher = Fernet(self.key)

    def encrypt(self, data: str) -> str:
        """åŠ å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher.encrypt(data.encode()).decode()

    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•æ„Ÿæ•°æ®"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# æ•æ„Ÿå­—æ®µå¤„ç†
class UserProfile(BaseModel):
    name: str
    email: str
    phone: Optional[str] = None
    encrypted_data: Optional[str] = None  # åŠ å¯†å­˜å‚¨çš„æ•æ„Ÿä¿¡æ¯

    def set_sensitive_data(self, data: Dict[str, str]):
        """è®¾ç½®æ•æ„Ÿæ•°æ®ï¼ˆè‡ªåŠ¨åŠ å¯†ï¼‰"""
        encryption = DataEncryption()
        self.encrypted_data = encryption.encrypt(json.dumps(data))

    def get_sensitive_data(self) -> Optional[Dict[str, str]]:
        """è·å–æ•æ„Ÿæ•°æ®ï¼ˆè‡ªåŠ¨è§£å¯†ï¼‰"""
        if not self.encrypted_data:
            return None

        try:
            encryption = DataEncryption()
            return json.loads(encryption.decrypt(self.encrypted_data))
        except Exception:
            return None
```

---

## ğŸ“ äº”ã€æ•°æ®å®Œæ•´æ€§å¼ºåˆ¶éªŒè¯

### 5.1 å¤–é”®å®Œæ•´æ€§æ£€æŸ¥

```python
# services/foreign_key_validator.py
from typing import Dict, Any, List, List
from sqlalchemy.orm import Session

class ForeignKeyValidator:
    @staticmethod
    def validate_create_request(
        payload: Dict[str, Any],
        db: Session,
        user: User,
        entity_type: str
    ) -> bool:
        """åˆ›å»ºè¯·æ±‚çš„å¤–é”®éªŒè¯"""

        foreign_key_rules = {
            "daily_report": {
                "ad_account_id": ["ad_accounts", "id"],
                "user_id": ["users", "id"],
                "project_id": ["projects", "id"]
            },
            "recharge_request": {
                "project_id": ["projects", "id"],
                "ad_account_id": ["ad_accounts", "id"],
                "user_id": ["users", "id"]
            },
            "ad_account": {
                "project_id": ["projects", "id"],
                "assigned_user_id": ["users", "id"],
                "channel_id": ["channels", "id", False]
            }
        }

        rules = foreign_key_rules.get(entity_type, {})
        for field, relation_config in rules.items():
            if field in payload:
                relation_table, relation_field = relation_config
                relation_id = payload.get(field)

                if relation_id:
                    # éªŒè¯å¤–é”®æ˜¯å¦å­˜åœ¨
                    exists = db.query(getattr(importlib.import_module(f"models.{relation_table}"), relation_table)).filter(
                        getattr(importlib.import_module(f"models.{relation_table}"), relation_field) == relation_id
                    ).first()

                    if not exists:
                        raise ValueError(f"{field}å¼•ç”¨çš„{relation_table}.{relation_field}ä¸å­˜åœ¨: {relation_id}")

                    # éªŒè¯æƒé™é“¾
                    if entity_type == "daily_report":
                        AccountOwnershipValidator.validate_account_ownership(
                            account_id=relation_id,
                            user_id=payload["user_id"],
                            db=db
                        )
                    elif entity_type == "ad_account":
                        ProjectOwnershipValidator.validate_project_access(
                            project_id=payload["project_id"],
                            user_id=payload.get("assigned_user_id"),
                            user_role=user.role,
                            db=db
                        )

        return True

class AccountOwnershipValidator:
    @staticmethod
    def validate_account_ownership(account_id: str, user_id: str, db: Session) -> bool:
        """éªŒè¯è´¦æˆ·æ‰€æœ‰æƒ"""
        account = db.query(AdAccount).filter(AdAccount.id == account_id).first()
        if not account:
            return False

        # ç®¡ç†å‘˜å’Œæˆ·ç®¡å¯ä»¥è®¿é—®æ‰€æœ‰è´¦æˆ·
        user = db.query(User).filter(User.id == user_id).first()
        if user and user.role in ["admin", "data_clerk"]:
            return True

        # æŠ•æ‰‹åªèƒ½è®¿é—®åˆ†é…ç»™è‡ªå·±çš„è´¦æˆ·
        return account.assigned_user_id == user_id

class ProjectOwnershipValidator:
    @staticmethod
    def validate_project_access(project_id: str, user_id: str, user_role: str, db: Session) -> bool:
        """éªŒè¯é¡¹ç›®è®¿é—®æƒé™"""
        project = db.query(Project).filter(Project.id == project_id).first()
        if not project:
            return False

        # ç®¡ç†å‘˜å…¨æƒé™
        if user_role == "admin":
            return True

        # æˆ·ç®¡å’Œè´¢åŠ¡å¯ä»¥æŸ¥çœ‹æ‰€æœ‰é¡¹ç›®
        if user_role in ["data_clerk", "finance"]:
            return True

        # æŠ•æ‰‹åªèƒ½è®¿é—®åˆ†é…ç»™è‡ªå·±çš„é¡¹ç›®
        user = db.query(User).filter(User.id == user_id).first()
        return project.manager_id == user.id
```

### 5.2 æ•°æ®æ ¼å¼æ ‡å‡†åŒ–

```python
# schemas/validation.py
from pydantic import validator, Field
from decimal import Decimal
from typing import List
import re

class ValidationMixin:
    """éªŒè¯è§„åˆ™æ··å…¥ç±»"""

    @validator('email')
    def validate_email(cls, v):
        """é‚®ç®±æ ¼å¼éªŒè¯"""
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', v):
            raise ValueError('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®')
        return v.lower()

    @validator('phone', pre=True, always=True)
    def validate_phone(cls, v):
        """æ‰‹æœºå·æ ¼å¼éªŒè¯"""
        if v and not re.match(r'^1[3-9]\d{9}$', v):
            raise ValueError('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®')
        return v

    @validator('amount')
    def validate_amount(cls, v):
        """é‡‘é¢æ ¼å¼éªŒè¯"""
        if v is not None and (v < 0 or v > 999999.99):
            raise ValueError('é‡‘é¢å¿…é¡»åœ¨0-999999.99ä¹‹é—´')
        return v

    @validator('budget')
    def validate_budget(cls, v):
        """é¢„ç®—æ ¼å¼éªŒè¯"""
        if v is not None and (v < 0 or v > 10000000):
            raise ValueError('é¢„ç®—å¿…é¡»åœ¨0-10000000ä¹‹é—´')
        return v

class ProjectCreate(BaseModel, ValidationMixin):
    name: str = Field(..., min_length=2, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    client_name: str = Field(..., min_length=2, max_length=200)
    budget: Decimal = Field(ge=100, decimal_places=2)
    start_date: Optional[date] = None
    end_date: Optional[date] = None

    @validator('end_date')
    def validate_end_date(cls, v, values):
        if v and values.get('start_date') and v < values['start_date']:
            raise ValueError('ç»“æŸæ—¥æœŸä¸èƒ½æ—©äºå¼€å§‹æ—¥æœŸ')
        return v

    @validator('client_name')
    def validate_client_name(cls, v):
        # æ¸…ç†å®¢æˆ·ç«¯åç§°ä¸­çš„ç‰¹æ®Šå­—ç¬¦
        return re.sub(r'[^\w\s\-]', '', v.strip())

class DailyReportCreate(BaseModel, ValidationMixin):
    ad_account_id: str
    report_date: date
    spend: Decimal = Field(ge=0, decimal_places=2)
    impressions: int = Field(ge=0)
    clicks: int = Field(ge=0)
    conversions: int = Field(ge=0)
    cpl: Optional[Decimal] = Field(None, ge=0)
    notes: Optional[str] = None

    @validator('report_date')
    def validate_report_date(cls, v):
        # ç¡®ä¿ä¸æ˜¯æœªæ¥æ—¥æœŸ
        today = date.today()
        if v > today:
            raise ValueError('æŠ¥å‘Šæ—¥æœŸä¸èƒ½æ˜¯æœªæ¥æ—¥æœŸ')
        return v

    @validator('cpl')
    def validate_cpl(cls, v, values):
        if v is not None and values.get('conversions', 0) > 0:
            calculated_cpl = values['spend'] / values['conversions']
            if abs(v - calculated_cpl) > calculated_cpl * 0.1:  # å…è®¸10%è¯¯å·®
                raise ValueError(f'CPLè®¡ç®—é”™è¯¯: {v}, åº”ä¸º {calculated_cpl:.2f}')
        return v
```

---

## ğŸš« å…­ã€æ€§èƒ½ä¼˜åŒ–å¼ºåˆ¶è¦æ±‚

### 6.1 æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

```python
# services/query_optimizer.py
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_
from sqlalchemy.orm import joinedload

class QueryOptimizer:
    @staticmethod
    def optimized_project_list_query(
        db: Session,
        page: int = 1,
        size: int = 20,
        filters: Dict[str, Any] = None
    ):
        """ä¼˜åŒ–çš„é¡¹ç›®åˆ—è¡¨æŸ¥è¯¢"""

        # æ„å»ºåŸºç¡€æŸ¥è¯¢
        query = db.query(Project).options(
            joinedload(Project.accounts),  # é¢„åŠ è½½å…³è”è´¦æˆ·
            joinedload(Project.manager)     # é¢„åŠ è½½ç®¡ç†å™¨
        )

        # åº”ç”¨è¿‡æ»¤æ¡ä»¶
        if filters:
            if filters.get('status'):
                query = query.filter(Project.status == filters['status'])

            if filters.get('client_name'):
                query = query.filter(
                    Project.client_name.ilike(f"%{filters['client_name']}%")
                )

            if filters.get('min_budget'):
                query = query.filter(Project.budget >= filters['min_budget'])

            if filters.get('max_budget'):
                query = query.filter(Project.budget <= filters['max_budget'])

        # åˆ†é¡µæŸ¥è¯¢
        offset = (page - 1) * size
        total = query.count()
        items = query.offset(offset).limit(size).all()

        return {
            'items': items,
            'total': total,
            'page': page,
            'size': size,
            'pages': (total + size - 1) // size + 1
        }

    @staticmethod
    def optimized_daily_report_query(
        db: Session,
        project_id: str,
        start_date: date,
        end_date: date
    ):
        """ä¼˜åŒ–çš„æ—¥æŠ¥æŸ¥è¯¢ï¼ˆå¸¦ç´¢å¼•åˆ©ç”¨ï¼‰"""

        return db.query(DailyReport).options(
            joinedload(DailyReport.ad_account)
        ).filter(
            and_(
                DailyReport.ad_account.has(Project.id == project_id),
                DailyReport.report_date.between(start_date, end_date),
                DailyReport.status == 'approved'
            )
        ).order_by(DailyReport.report_date.desc())

    @staticmethod
    def get_account_performance_summary(
        db: Session,
        account_id: str,
        days: int = 30
    ):
        """è·å–è´¦æˆ·æ€§èƒ½æ±‡æ€»"""
        end_date = date.today()
        start_date = end_date - timedelta(days=days)

        # ä½¿ç”¨åŸç”ŸSQLæé«˜æ€§èƒ½
        result = db.execute("""
            SELECT
                COUNT(*) as report_count,
                SUM(spend) as total_spend,
                SUM(impressions) as total_impressions,
                SUM(clicks) as total_clicks,
                SUM(conversions) as total_conversions,
                AVG(cpl) as avg_cpl,
                DATE(report_date) as last_report_date
            FROM daily_reports
            WHERE
                ad_account_id = :account_id
                AND report_date >= :start_date
                AND report_date <= :end_date
                AND status = 'approved'
            GROUP BY DATE(report_date)
            ORDER BY report_date DESC
        """, {
            'account_id': account_id,
            'start_date': start_date,
            'end_date': end_date
        })

        return result.all()
```

### 6.2 ç¼“å­˜ç­–ç•¥

```python
# services/cache_service.py
import redis
import json
import pickle
from typing import Any, Optional, Union
from datetime import timedelta

class CacheService:
    def __init__(self):
        self.redis_client = redis.Redis(
            host=os.getenv('REDIS_HOST', 'localhost'),
            port=int(os.getenv('REDIS_PORT', 6379)),
            db=int(os.getenv('REDIS_DB', 0))
        )
        self.default_ttl = 3600  # 1å°æ—¶

    def get_cache_key(self, prefix: str, identifier: str) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        return f"{prefix}:{identifier}"

    def get(self, prefix: str, identifier: str) -> Optional[Any]:
        """è·å–ç¼“å­˜æ•°æ®"""
        key = self.get_cache_key(prefix, identifier)
        try:
            cached_data = self.redis_client.get(key)
            if cached_data:
                return pickle.loads(cached_data)
        except Exception:
            pass
        return None

    def set(self, prefix: str, identifier: str, data: Any, ttl: Optional[int] = None) -> bool:
        """è®¾ç½®ç¼“å­˜æ•°æ®"""
        key = self.get_cache_key(prefix, identifier)
        try:
            ttl = ttl or self.default_ttl
            serialized_data = pickle.dumps(data)
            return self.redis_client.setex(key, ttl, serialized_data)
        except Exception as e:
            log_error(f"ç¼“å­˜è®¾ç½®å¤±è´¥: {e}")
            return False

    def delete(self, prefix: str, identifier: str) -> bool:
        """åˆ é™¤ç¼“å­˜æ•°æ®"""
        key = self.get_cache_key(prefix, identifier)
        try:
            return self.redis_client.delete(key)
        except Exception:
            return False

    def invalidate_pattern(self, pattern: str) -> int:
        """æŒ‰æ¨¡å¼åˆ é™¤ç¼“å­˜"""
        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
        except Exception:
            return 0

# ç¼“å­˜è£…é¥°å™¨
def cached_result(prefix: str, ttl: int = 3600):
    """æŸ¥è¯¢ç»“æœç¼“å­˜è£…é¥°å™¨"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            # ç”Ÿæˆç¼“å­˜é”®
            cache_key = f"{prefix}:{hash(str(args) + str(kwargs))}"

            # å°è¯•ä»ç¼“å­˜è·å–
            cache_service = CacheService()
            cached_result = cache_service.get(prefix, cache_key)
            if cached_result:
                return cached_result

            # æ‰§è¡ŒåŸå‡½æ•°
            result = func(*args, **kwargs)

            # ç¼“å­˜ç»“æœ
            cache_service.set(prefix, cache_key, result, ttl)
            return result

        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@cached_result(prefix="projects", ttl=1800)
def get_project_list(page: int = 1, size: int = 20):
    return db.query(Project).offset((page-1)*size).limit(size).all()
```

---

## ğŸ“‹ ä¸ƒã€æµ‹è¯•ä»£ç å¼ºåˆ¶è¦æ±‚

### 7.1 å•å…ƒæµ‹è¯•æ¨¡æ¿

```python
# tests/unit/test_recharge_service.py
import pytest
from unittest.mock import Mock, patch
from decimal import Decimal
from datetime import date
from services.recharge_service import RechargeService
from models.recharge_request import RechargeRequest, RechargeStatus

class TestRechargeService:

    @pytest.fixture
    def recharge_service(self, db_session):
        return RechargeService(db_session)

    @pytest.fixture
    def sample_user(self, db_session):
        user = User(
            id="test-user-id",
            email="test@example.com",
            role="media_buyer",
            is_active=True
        )
        db_session.add(user)
        db_session.commit()
        return user

    @pytest.fixture
    def sample_project(self, db_session, sample_user):
        project = Project(
            id="test-project-id",
            name="Test Project",
            client_name="Test Client",
            manager_id=sample_user.id,
            budget=Decimal("10000.00")
        )
        db_session.add(project)
        db_session.commit()
        return project

    @pytest.fixture
    def sample_account(self, db_session, sample_project, sample_user):
        account = AdAccount(
            id="test-account-id",
            name="Test Account",
            account_id="act_test123",
            platform="facebook",
            status="active",
            project_id=sample_project.id,
            assigned_user_id=sample_user.id
        )
        db_session.add(account)
        db_session.commit()
        return account

    def test_create_recharge_request_success(self, recharge_service, sample_project, sample_account, sample_user):
        """æµ‹è¯•åˆ›å»ºå……å€¼ç”³è¯·æˆåŠŸ"""
        data = RechargeRequestCreate(
            project_id=str(sample_project.id),
            ad_account_id=str(sample_account.id),
            amount=Decimal("1000.00"),
            notes="Test recharge"
        )

        request = recharge_service.create_recharge(data, sample_user.id)

        assert request is not None
        assert request.status == RechargeStatus.DRAFT
        assert request.project_id == sample_project.id
        assert request.ad_account_id == sample_account.id
        assert request.user_id == sample_user.id
        assert request.amount == Decimal("1000.00")

    def test_create_recharge_request_invalid_amount(self, recharge_service, sample_project, sample_account, sample_user):
        """æµ‹è¯•åˆ›å»ºå……å€¼ç”³è¯·é‡‘é¢æ— æ•ˆ"""
        data = RechargeRequestCreate(
            project_id=str(sample_project.id),
            ad_account_id=str(sample_account.id),
            amount=Decimal("-100.00"),  # è´Ÿæ•°é‡‘é¢
            notes="Test recharge"
        )

        with pytest.raises(ValueError, match="é‡‘é¢å¿…é¡»åœ¨0-999999.99ä¹‹é—´"):
            recharge_service.create_recharge(data, sample_user.id)

    def test_create_recharge_request_foreign_key_mismatch(self, recharge_service, sample_project, sample_user):
        """æµ‹è¯•åˆ›å»ºå……å€¼è¯·æ±‚å¤–é”®ä¸åŒ¹é…"""
        other_project = Project(
            id="other-project-id",
            name="Other Project"
        )

        data = RechargeRequestCreate(
            project_id=other_project.id,  # é”™è¯¯çš„é¡¹ç›®ID
            ad_account_id=str(sample_account.id),
            amount=Decimal("1000.00")
        )

        with pytest.raises(ValueError, match="è´¦æˆ·-é¡¹ç›®ä¸åŒ¹é…"):
            recharge_service.create_recharge(data, sample_user.id)

    def test_approve_recharge_success(self, recharge_service, db_session, sample_user):
        """æµ‹è¯•å®¡æ‰¹å……å€¼ç”³è¯·æˆåŠŸ"""
        # å…ˆåˆ›å»ºä¸€ä¸ªå¾…å®¡æ‰¹çš„å……å€¼ç”³è¯·
        recharge_request = RechargeRequest(
            project_id="test-project-id",
            ad_account_id="test-account-id",
            user_id=sample_user.id,
            amount=Decimal("1000.00"),
            status=RechargeStatus.PENDING
        )
        db_session.add(recharge_request)
        db_session.commit()

        # æ¨¡æ‹Ÿæˆ·ç®¡ç”¨æˆ·ï¼ˆåº”è¯¥æœ‰å®¡æ‰¹æƒé™ï¼‰
        clerk_user = Mock()
        clerk_user.id = "clerk-user-id"
        clerk_user.role = "data_clerk"

        # æ‰§è¡Œå®¡æ‰¹
        result = recharge_service.approve_recharge(
            recharge_request.id,
            clerk_user.id,
            clerk_user.role
        )

        assert result is True
        assert result["status"] == RechargeStatus.APPROVED

        # éªŒè¯çŠ¶æ€æ›´æ–°
        updated_request = db_session.query(RechargeRequest).filter(
            RechargeRequest.id == recharge_request.id
        ).first()
        assert updated_request.status == RechargeStatus.APPROVED
        assert updated_request.data_clerk_id == clerk_user.id
        assert updated_request.data_clerk_approved_at is not None
```

### 7.2 APIæµ‹è¯•æ¨¡æ¿

```python
# tests/api/test_recharge_api.py
from fastapi.testclient import TestClient
import pytest
from datetime import date

class TestRechargeAPI:
    @pytest.fixture
    def client(self, app):
        return TestClient(app)

    @pytest.fixture
    def auth_headers(self):
        return {
            "Authorization": "Bearer test-token"
        }

    def test_create_recharge_request_success(self, client, auth_headers, sample_project, sample_account, sample_user):
        """æµ‹è¯•åˆ›å»ºå……å€¼ç”³è¯·APIæˆåŠŸ"""
        data = {
            "project_id": str(sample_project.id),
            "ad_account_id": str(sample_account.id),
            "amount": "1000.00",
            "notes": "Test recharge via API"
        }

        response = client.post(
            "/api/recharge/request",
            json=data,
            headers=auth_headers
        )

        assert response.status_code == 201
        assert response.json()["success"] is True
        assert response.json()["data"]["status"] == "draft"

    def test_create_recharge_request_invalid_amount(self, client, auth_headers, sample_project, sample_account, sample_user):
        """æµ‹è¯•åˆ›å»ºå……å€¼ç”³è¯·é‡‘é¢æ— æ•ˆ"""
        data = {
            "project_id": str(sample_project.id),
            "ad_account_id": str(sample_account.id),
            "amount": "-100.00"  # è´Ÿæ•°é‡‘é¢
        }

        response = client.post(
            "/api/recharge/request",
            json=data,
            headers=auth_headers
        )

        assert response.status_code == 422
        assert response.json()["success"] is False
        assert "é‡‘é¢" in response.json()["error"]["message"]

    def test_create_recharge_request_unauthorized(self, client, sample_project, sample_account, sample_user):
        """æµ‹è¯•æœªæˆæƒåˆ›å»ºå……å€¼ç”³è¯·"""
        data = {
            "project_id": str(sample_project.id),
            "ad_account_id": str(sample_account.id),
            "amount": "1000.00"
        }

        response = client.post("/api/recharge/request", json=data)

        assert response.status_code == 401
        assert response.json()["success"] is False
        assert response.json()["error"]["code"] == "UNAUTHORIZED"

    def test_approve_recharge_success(self, client, auth_headers, db_session, sample_user, sample_request):
        """æµ‹è¯•å®¡æ‰¹å……å€¼ç”³è¯·APIæˆåŠŸ"""
        # å…ˆåˆ›å»ºä¸€ä¸ªå¾…å®¡æ‰¹çš„å……å€¼ç”³è¯·
        recharge_request = RechargeRequest(
            project_id="test-project-id",
            ad_account_id="test-account-id",
            user_id=sample_user.id,
            amount=Decimal("1000.00"),
            status=RechargeStatus.PENDING
        )
        db_session.add(recharge_request)
        db_session.commit()

        # åˆ›å»ºæˆ·ç®¡ç”¨æˆ·
        clerk_user = Mock()
        clerk_user.id = "clerk-user-id"
        clerk_user.role = "data_clerk"

        # æ¨¡æ‹Ÿæƒé™éªŒè¯
        with patch('backend.core.security.get_current_user', return_value=clerk_user):
            response = client.post(
                f"/api/recharge/{recharge_request.id}/approve",
                headers=auth_headers
            )

        assert response.status_code == 200
        assert response.json()["success"] is True
        assert response.json()["data"]["status"] == "approved"
```

---

## ğŸ“ å…«ã€æ—¥å¿—å’Œå®¡è®¡å¼ºåˆ¶è¦æ±‚

### 8.1 æ“ä½œæ—¥å¿—è®°å½•

```python
# services/audit_log_service.py
from datetime import datetime
from typing import Any, Dict
from sqlalchemy.orm import Session
from models.audit_log import AuditLog
import json

class AuditLogService:
    @staticmethod
    def log_action(
        action: str,
        table_name: str,
        record_id: str,
        user_id: str,
        old_data: Optional[Dict[str, Any]] = None,
        new_data: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """è®°å½•æ“ä½œæ—¥å¿—"""

        try:
            log_entry = AuditLog(
                action=action,
                table_name=table_name,
                record_id=record_id,
                user_id=user_id,
                old_data=json.dumps(old_data) if old_data else None,
                new_data=json.dumps(new_data) if new_data else None,
                ip_address=ip_address,
                user_agent=user_agent,
                metadata=json.dumps(metadata) if metadata else None,
                timestamp=datetime.utcnow(),
                created_at=datetime.utcnow()
            )

            db.add(log_entry)
            db.commit()

        except Exception as e:
            # è®°å½•æ—¥å¿—é”™è¯¯ä½†ä¸å½±å“ä¸»æµç¨‹
            print(f"æ—¥å¿—è®°å½•å¤±è´¥: {e}")

# è‡ªåŠ¨å®¡è®¡è£…é¥°å™¨
def audit_action(action: str, table_name: str):
    """è‡ªåŠ¨å®¡è®¡è£…é¥°å™¨"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            try:
                # è·å–è¯·æ±‚ä¸Šä¸‹æ–‡
                request = kwargs.get('request')
                user = getattr(request.state, 'current_user', None)

                # æå–ä¿®æ”¹å‰æ•°æ®
                old_data = None
                if request and hasattr(request, 'old_data'):
                    old_data = request.old_data

                # æ‰§è¡ŒåŸå‡½æ•°
                result = await func(*args, **kwargs)

                # æå–ä¿®æ”¹åæ•°æ®
                new_data = result.get('data') if isinstance(result, dict) else None

                # è®°å½•æ“ä½œæ—¥å¿—
                if user and request:
                    AuditLogService.log_action(
                        action=action,
                        table_name=table_name,
                        record_id=str(kwargs.get('id') or ''),
                        user_id=user.id,
                        old_data=old_data,
                        new_data=new_data,
                        ip_address=request.client.host,
                        user_agent=request.headers.get('user-agent'),
                        metadata={'request_method': request.method}
                    )

                return result

            except Exception as e:
                # è®°å½•é”™è¯¯æ—¥å¿—
                print(f"è‡ªåŠ¨å®¡è®¡å¤±è´¥: {e}")
                raise

        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@audit_action("create", "projects")
async def create_project(project_data: ProjectCreate):
    # é¡¹ç›®åˆ›å»ºé€»è¾‘
    project = Project(**project_data.dict())
    db.add(project)
    db.commit()

    return success_response(data=project)
```

### 8.2 å¼‚å¸¸ç›‘æ§æ—¥å¿—

```python
# services/error_monitoring.py
import traceback
import logging
from datetime import datetime
from typing import Optional

class ErrorMonitoringService:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def log_exception(
        self,
        exception: Exception,
        context: Dict[str, Any] = None,
        user_id: Optional[str] = None,
        request_id: Optional[str] = None
    ):
        """è®°å½•å¼‚å¸¸ä¿¡æ¯"""

        error_info = {
            "timestamp": datetime.utcnow().isoformat(),
            "exception_type": type(exception).__name__,
            "exception_message": str(exception),
            "traceback": traceback.format_exc(),
            "context": context or {},
            "user_id": user_id,
            "request_id": request_id
        }

        self.logger.error(f"Exception occurred: {json.dumps(error_info)}")

        # å¯ä»¥å‘é€åˆ°å¤–éƒ¨ç›‘æ§ç³»ç»Ÿ
        if os.getenv("SENTRY_DSN"):
            self.send_to_sentry(error_info)

    def send_to_sentry(self, error_info: Dict[str, Any]):
        """å‘é€åˆ°Sentry"""
        try:
            import sentry_sdk
            sentry_sdk.init(
                dsn=os.getenv("SENTRY_DSN"),
                traces_sample_rate=1.0
            )

            sentry_sdk.capture_exception(Exception(
                error_info.get("exception_message"),
                extra=error_info
            )
        except Exception as e:
            self.logger.error(f"å‘é€Sentryå¤±è´¥: {e}")

# å…¨å±€å¼‚å¸¸å¤„ç†å™¨
@app.exception_handler()
async def global_exception_handler(request: Request, exc: Exception):
    """å…¨å±€å¼‚å¸¸å¤„ç†å™¨"""
    error_monitoring = ErrorMonitoringService()

    # è®°å½•å¼‚å¸¸
    error_monitoring.log_exception(
        exception=exc,
        context={
            "method": request.method,
            "url": str(request.url),
            "headers": dict(request.headers)
        },
        user_id=getattr(request.state, 'current_user', {}).get('id'),
        request_id=getattr(request.state, 'request_id')
    )

    # è¿”å›ç»Ÿä¸€é”™è¯¯å“åº”
    return error_response(
        message="å†…éƒ¨æœåŠ¡å™¨é”™è¯¯",
        code="INTERNAL_ERROR",
        status_code=500
    )
```

---

## ğŸ”Ÿ ä¹ã€Cursorå¼ºåˆ¶æ£€æŸ¥æ¸…å•

### 9.1 ä»£ç ç”Ÿæˆå‰æ£€æŸ¥é¡¹

```markdown
## Cursorç”Ÿæˆä»£ç å‰å¿…é¡»éªŒè¯ä»¥ä¸‹é¡¹ç›®

### âœ… å“åº”æ ¼å¼æ£€æŸ¥
- [ ] æ‰€æœ‰æ¥å£ä½¿ç”¨ `success_response()` æˆ– `error_response()`
- [ ] è¿”å›ç»“æ„ç¬¦åˆ `{success, data, message, code, request_id, timestamp}` æ ¼å¼
- [ ] é”™è¯¯å“åº”åŒ…å«è¯¦ç»†çš„é”™è¯¯ç å’Œæ¶ˆæ¯
- [ ] æˆåŠŸå“åº”åŒ…å«å®Œæ•´çš„ä¸šåŠ¡æ•°æ®

### âœ… æ•°æ®æ¨¡å‹æ£€æŸ¥
- [ ] æ‰€æœ‰æ¨¡å‹ç»§æ‰¿ `BaseModel` å¹¶åŒ…å«æ—¶é—´æˆ³å­—æ®µ
- [ ] é‡‘é¢å­—æ®µä½¿ç”¨ `Decimal` ç±»å‹ï¼Œç¦æ­¢ä½¿ç”¨ `float`
- [ ] Pydantic Schema é…ç½® `json_encoders = {Decimal: str}`
- [ ] å¤–é”®å…³ç³»å®šä¹‰æ­£ç¡®å¹¶å»ºç«‹çº¦æŸ
- [ ] ä½¿ç”¨ `@validator` è¿›è¡Œæ•°æ®éªŒè¯

### âœ… çŠ¶æ€æœºæ£€æŸ¥
- [ ] å……å€¼çŠ¶æ€è½¬æ¢éµå¾ªv2.1ä¸»æ–‡æ¡£ç¬¬2ç« è§„åˆ™
- [ ] çŠ¶æ€è½¬æ¢åŒ…å«æƒé™æ£€æŸ¥
- [ ] éæ³•çŠ¶æ€è½¬æ¢ä¼šæŠ›å‡º 422 é”™è¯¯
- [ ] çŠ¶æ€å˜æ›´è®°å½•å®¡è®¡æ—¥å¿—

### âœ… å®‰å…¨æ£€æŸ¥
- [ ] æ‰€æœ‰æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] JWTå¯†é’¥é•¿åº¦ä¸å°‘äº32ä½
- [ ] ç”¨æˆ·è®¤è¯ä¾èµ–æ­£ç¡®ä½¿ç”¨
- [ ] æƒé™æ§åˆ¶åŸºäºè§’è‰²å’Œä¸šåŠ¡è§„åˆ™
- [ ] å‰ç«¯ç¦ç”¨ç›´æ¥æ•°æ®åº“å†™æ“ä½œ

### âœ… æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
- [ ] æ‰€æœ‰åŒ…å«å¤–é”®çš„è¯·æ±‚è¿›è¡Œä¸€è‡´æ€§éªŒè¯
- [ | é¡¹ç›®-è´¦æˆ·-ç”¨æˆ·æƒé™é“¾å®Œæ•´
- [ | éªŒè¯å¤–é”®å¼•ç”¨çš„å®ä½“å­˜åœ¨
- [ | ä¸åŒ¹é…çš„æ•°æ®è¿”å›422é”™è¯¯

### âœ… æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥
- [ ] æŸ¥è¯¢ä½¿ç”¨é€‚å½“çš„ç´¢å¼•
- [ ] åˆ—è¡¨æŸ¥è¯¢åŒ…å«åˆ†é¡µå‚æ•°
- [ ] ç¼“å­˜ç­–ç•¥é…ç½®åˆç†
- [ ] é¿å…N+1æŸ¥è¯¢é—®é¢˜

### âœ… æ—¥å¿—è®°å½•æ£€æŸ¥
- [ ] æ‰€æœ‰å†™æ“ä½œéƒ½è®°å½•å®¡è®¡æ—¥å¿—
- [ ] æ—¥å¿—åŒ…å«å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
- [ ] å¼‚å¸¸æƒ…å†µè®°å½•é”™è¯¯è¿½è¸ªä¿¡æ¯
- [ ] å…³é”®æ“ä½œæœ‰è¯¦ç»†çš„æ“ä½œè®°å½•

### âœ… ä»£ç è´¨é‡æ£€æŸ¥
- [ ] ä»£ç éµå¾ªPEP8è§„èŒƒ
- [ ] åŒ…å«é€‚å½“çš„ç±»å‹æ³¨è§£
- [ ] ä½¿ç”¨ç»Ÿä¸€çš„å‘½åè§„èŒƒ
- [ ] é¿å…é‡å¤ä»£ç å’Œé€»è¾‘

### âœ… æµ‹è¯•è¦æ±‚æ£€æŸ¥
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
- [ ] APIæµ‹è¯•åŒ…å«æ­£å¸¸å’Œå¼‚å¸¸æƒ…å†µ
- [ ] é›†æˆæµ‹è¯•éªŒè¯ä¸šåŠ¡æµç¨‹
- [ ] åŒ…å«æƒé™å’Œå®‰å…¨æµ‹è¯•

å¦‚æœä»»æ„é¡¹ç›®æœªé€šè¿‡ï¼ŒCursorå¿…é¡»è¿”å›é”™è¯¯è¯´æ˜å¹¶åœæ­¢ç”Ÿæˆä»£ç ã€‚

### 9.2 å¸¸è§é”™è¯¯ç±»å‹å’Œå¤„ç†

#### ç±»å‹1ï¼šå“åº”æ ¼å¼é”™è¯¯
```python
# âŒ é”™è¯¯ç¤ºä¾‹
return {"status": "success", "data": {...}}

# âœ… æ­£ç¡®ç¤ºä¾‹
return success_response(data=data)
```

#### ç±»å‹2ï¼šæ•°æ®ç±»å‹é”™è¯¯
```python
# âŒ é”™è¯¯ç¤ºä¾‹
amount: float  # ä¸èƒ½ä½¿ç”¨float

# âœ… æ­£ç¡®ç¤ºä¾‹
amount: Decimal(100.50)
```

#### ç±»å‹3ï¼šçŠ¶æ€æœºé”™è¯¯
```python
# âŒ é”™è¯¯ç¤ºä¾‹
status = "approved"  # ç¼ºå°‘çŠ¶æ€æœºéªŒè¯

# âœ… æ­£ç¡®ç¤ºä¾‹
if validate_state_transition(current_status, "approved", user_role, user_id):
    status = "approved"
else:
    return error_response("çŠ¶æ€è½¬æ¢ä¸è¢«å…è®¸", "INVALID_STATE_TRANSITION", 422)
```

#### ç±»å‹4ï¼šå®‰å…¨è¿è§„
```python
# âŒ é”™è¯¯ç¤ºä¾‹
# å‰ç«¯ç›´æ¥å†™æ•°æ®åº“
await supabase.from('projects').insert({...})

# âœ… æ­£ç¡®ç¤ºä¾‹
await apiFetch('/api/projects', {
    method: 'POST',
    data: project_data
})
```

---

## ğŸ“š åã€è¿è§„å¤„ç†å’Œæ¢å¤

### 10.1 è¿è§„æ£€æµ‹æœºåˆ¶

```python
# tools/code_validator.py
class CodeValidator:
    def __init__(self):
        self.violations = []

    def validate_response_format(self, code_str: str) -> List[str]:
        """æ£€æŸ¥å“åº”æ ¼å¼è¿è§„"""
        violations = []

        # æ£€æŸ¥ç›´æ¥è¿”å›å­—å…¸
        if "return {" in code_str and "return {" not in code_str:
            if "return {" in code_str and "error" not in code_str:
                violations.append("ç›´æ¥è¿”å›å­—å…¸ï¼Œå¿…é¡»ä½¿ç”¨success_response()æˆ–error_response()")

        # æ£€æŸ¥ä½¿ç”¨raise HTTPException
        if "raise HTTPException" in code_str:
            violations.append("ç¦æ­¢ç›´æ¥ä½¿ç”¨HTTPExceptionï¼Œå¿…é¡»ä½¿ç”¨error_response()")

        return violations

    def validate_sql_alchemy_usage(self, code_str: str) -> List[str]:
        """æ£€æŸ¥SQLAlchemyä½¿ç”¨è¿è§„"""
        violations = []

        # æ£€æŸ¥å¼‚æ­¥ç”¨æ³•
        if "async def" in code_str and "Session" in code_str:
            violations.append("SQLAlchemyåŒæ­¥ç‰ˆæœ¬ä¸èƒ½ä½¿ç”¨async/await")

        # æ£€æŸ¥å…¨å±€å˜é‡ä½¿ç”¨
        if "Session()" in code_str and "Depends" not in code_str:
            violations.append("å¿…é¡»ä½¿ç”¨Depends(get_db)ä¾èµ–æ³¨å…¥")

        # æ£€æŸ¥ç›´æ¥å­—ç¬¦ä¸²SQL
        if 'execute("' in code_str and "SELECT" in code_str:
            violations.append("ç¦æ­¢ä½¿ç”¨åŸç”ŸSQLï¼Œè¯·ä½¿ç”¨ORMæ–¹æ³•")

        return violations

    def validate_state_machine_usage(self, code_str: str) -> List[str]:
        """æ£€æŸ¥çŠ¶æ€æœºä½¿ç”¨è¿è§„"""
        violations = []

        # æ£€æŸ¥çŠ¶æ€ç›´æ¥è®¾ç½®
        if ".status = " in code_str and "RechargeStatus." not in code_str:
            violations.append("ç¦æ­¢ç›´æ¥è®¾ç½®çŠ¶æ€ï¼Œå¿…é¡»ä½¿ç”¨çŠ¶æ€æœºéªŒè¯")

        # æ£€æŸ¥è·³è¿‡çŠ¶æ€éªŒè¯
        if "skip_validation" in code_str or "validate_" not in code_str:
            violations.append("å¿…é¡»ä½¿ç”¨çŠ¶æ€æœºéªŒè¯å‡½æ•°")

        return violations

    def validate_security_requirements(self, code_str: str) -> List[str]:
        """æ£€æŸ¥å®‰å…¨è¦æ±‚è¿è§„"""
        violations = []

        # æ£€æŸ¥ç¡¬ç¼–ç å¯†é’¥
        if "secret" in code_str.lower() or "password" in code_str.lower():
            violations.append("ç¦æ­¢ç¡¬ç¼–ç å¯†é’¥ï¼Œå¿…é¡»ä½¿ç”¨ç¯å¢ƒå˜é‡")

        # æ£€æŸ¥SQLæ³¨å…¥é£é™©
        if "f\" OR '1'='1" in code_str:
            violations.append("å¯èƒ½å­˜åœ¨SQLæ³¨å…¥é£é™©ï¼Œè¯·ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢")

        # æ£€æŸ¥XSSé£é™©
        if "<script>" in code_str or "document.cookie" in code_str:
            violations.append("å¯èƒ½å­˜åœ¨XSSé£é™©ï¼Œè¯·è¿›è¡Œæ•°æ®æ¸…ç†")

        return violations

    def validate_all(self, code_str: str, user_role: str = "developer") -> Dict[str, List[str]]:
        """æ‰§è¡Œæ‰€æœ‰éªŒè¯"""

        violations = []

        # æ ¹æ®ç”¨æˆ·è§’è‰²è°ƒæ•´éªŒè¯ä¸¥æ ¼åº¦
        if user_role == "junior":
            # åˆçº§å¼€å‘è€…æ›´ä¸¥æ ¼æ£€æŸ¥
            validators = [
                self.validate_response_format,
                self.validate_sql_alchemy_usage,
                self.validate_state_machine_usage,
                self.validate_security_requirements
            ]
        elif user_role == "senior":
            # é«˜çº§å¼€å‘è€…å…è®¸ä¸€äº›çµæ´»æ€§
            validators = [
                self.validate_response_format,
                self.validate_foreign_key_integrity,
                self.validate_audit_logging
            ]
        else:
            # ä¸­çº§å¼€å‘è€…æ ‡å‡†æ£€æŸ¥
            validators = [
                self.validate_response_format,
                self.validate_sql_alchemy_usage,
                self.validate_foreign_key_integrity,
                self.validate_state_machine_usage
            ]

        all_violations = []
        for validator in validators:
            violations.extend(validator(code_str))

        return {
            "success": len(all_violations) == 0,
            "violations": all_violations,
            "error_count": len(all_violations),
            "critical_issues": [v for v in all_violations if "ç¦æ­¢" in v]
        }
```

### 10.2 è¿è§„æ¢å¤æŒ‡å—

```python
# tools/code_formatter.py
class CodeFormatter:
    @staticmethod
    def fix_response_format(code_str: str) -> str:
        """ä¿®å¤å“åº”æ ¼å¼"""
        # æ›¿æ¢ç›´æ¥è¿”å›å­—å…¸
        code_str = re.sub(
            r'return\s*\{\s*([^}]*)\s*\}',
            'return success_response(data=\\1)',
            code_str
        )

        # æ›¿æ¢HTTPException
        code_str = re.sub(
            r'raise\s*HTTPException\s*\(',
            'return error_response("message", "ERROR", status_code=400)',
            code_str
        )

        return code_str

    @staticmethod
    def fix_decimal_usage(code_str: str) -> str:
        """ä¿®å¤Decimalä½¿ç”¨"""
        # å°†floatæ›¿æ¢ä¸ºDecimal
        code_str = re.sub(
            r':\s*(\d+\.\d+)\s*(?!\s*\))',
            ': Decimal(\\1)',
            code_str
        )

        # æ·»åŠ importè¯­å¥å¦‚æœéœ€è¦
        if 'Decimal' in code_str and 'from decimal import' not in code_str:
            code_str = 'from decimal import Decimal\n' + code_str

        return code_str

    @staticmethod
    def fix_sqlalchemy_sync_usage(code_str: str) -> str:
        """ä¿®å¤SQLAlchemyåŒæ­¥ç‰ˆæœ¬ä½¿ç”¨"""
        # ç§»é™¤async/await
        code_str = re.sub(r'async\s+def\s+\w+\(',
            'def ', code_str)

        # æ·»åŠ ä¾èµ–æ³¨å…¥
        if "def (" in code_str and "Session" in code_str):
            code_str = re.sub(
                r'def\s*\([^)]*db:\s*Session',
                'def \\1(db: Session',
                code_str
            )

        return code_str
```

### 10.3 è‡ªåŠ¨ä¿®å¤å·¥å…·

```python
# tools/auto_fixer.py
import re
from typing import Dict, List

class AutoFixer:
    def auto_fix_response_format(self, code_str: str) -> str:
        """è‡ªåŠ¨ä¿®å¤å“åº”æ ¼å¼"""
        return CodeFormatter.fix_response_format(code_str)

    def auto_fix_decimal_usage(self, code_str: str) -> str:
        """è‡ªåŠ¨ä¿®å¤Decimalä½¿ç”¨"""
        return CodeFormatter.fix_decimal_usage(code_str)

    def auto_fix_sqlalchemy_sync(self, code_str: str) -> str:
        """è‡ªåŠ¨ä¿®å¤SQLAlchemyåŒæ­¥ç‰ˆä½¿ç”¨"""
        return CodeFormatter.fix_sqlalchemy_sync_usage(code_str)

    def fix_all_violations(self, code_str: str) -> str:
        """ä¿®å¤æ‰€æœ‰æ£€æµ‹åˆ°çš„è¿è§„"""
        violations = CodeValidator().validate_all(code_str)

        if violations["success"]:
            return code_str

        # æŒ‰ä¸¥é‡ç¨‹åº¦æ’åºä¿®å¤
        for violation in violations["violations"]:
            code_str = self._fix_by_violation_type(violation, code_str)

        return code_str

    def _fix_by_violation_type(self, violation: str, code_str: str) -> str:
        """æ ¹æ®è¿è§„ç±»å‹ä¿®å¤ä»£ç """
        if "responseæ ¼å¼" in violation:
            return CodeFormatter.fix_response_format(code_str)
        elif "æ•°æ®ç±»å‹" in violation:
            return CodeFormatter.fix_decimal_usage(code_str)
        elif "SQLAlchemy" in violation:
            return CodeFormatter.fix_sqlalchemy_sync(code_str)
        elif "å®‰å…¨è¦æ±‚" in violation:
            return code_str + "\n# âš ï¸ å®‰å…¨è¿è§„è­¦å‘Šï¼šè¯·æ‰‹åŠ¨ä¿®å¤å®‰å…¨é—®é¢˜"

        return code_str
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.1
**æœ€åæ›´æ–°**: 2025-11-11
**ä¸‹æ¬¡å®¡æŸ¥**: åŠŸèƒ½é‡å¤§å˜æ›´æ—¶
**ç»´æŠ¤è´£ä»»äºº**: é¡¹ç›®æ¶æ„å›¢é˜Ÿ